'use strict';

module.exports = function (Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.polarArea = {

		scale: {
			type: 'radialLinear',
			lineArc: true, // so that lines are circular
			ticks: {
				beginAtZero: true
			}
		},

		// Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},

		startAngle: -0.5 * Math.PI,
		aspectRatio: 1,
		legendCallback: function legendCallback(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i < datasets[0].data.length; ++i) {
					text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</li>');
				}
			}

			text.push('</ul>');
			return text.join('');
		},
		legend: {
			labels: {
				generateLabels: function generateLabels(chart) {
					var data = chart.data;
					if (data.labels.length && data.datasets.length) {
						return data.labels.map(function (label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function onClick(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}

				chart.update();
			}
		},

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function title() {
					return '';
				},
				label: function label(tooltipItem, data) {
					return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;
				}
			}
		}
	};

	Chart.controllers.polarArea = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Arc,

		linkScales: helpers.noop,

		update: function update(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var meta = me.getMeta();
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

			me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
			me.innerRadius = me.outerRadius - chart.radiusLength;

			meta.count = me.countVisibleElements();

			helpers.each(meta.data, function (arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function updateElement(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var dataset = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var scale = chart.scale;
			var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
			var labels = chart.data.labels;

			var circumference = me.calculateCircumference(dataset.data[index]);
			var centerX = scale.xCenter;
			var centerY = scale.yCenter;

			// If there is NaN data before us, we need to calculate the starting angle correctly.
			// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
			var visibleCount = 0;
			var meta = me.getMeta();
			for (var i = 0; i < index; ++i) {
				if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
					++visibleCount;
				}
			}

			// var negHalfPI = -0.5 * Math.PI;
			var datasetStartAngle = opts.startAngle;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			var startAngle = datasetStartAngle + circumference * visibleCount;
			var endAngle = startAngle + (arc.hidden ? 0 : circumference);

			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: centerX,
					y: centerY,
					innerRadius: 0,
					outerRadius: reset ? resetRadius : distance,
					startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
					endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
					label: getValueAtIndexOrDefault(labels, index, labels[index])
				}
			});

			// Apply border and fill style
			me.removeHoverStyle(arc);

			arc.pivot();
		},

		removeHoverStyle: function removeHoverStyle(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		countVisibleElements: function countVisibleElements() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var count = 0;

			helpers.each(meta.data, function (element, index) {
				if (!isNaN(dataset.data[index]) && !element.hidden) {
					count++;
				}
			});

			return count;
		},

		calculateCircumference: function calculateCircumference(value) {
			var count = this.getMeta().count;
			if (count > 0 && !isNaN(value)) {
				return 2 * Math.PI / count;
			}
			return 0;
		}
	});
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRyb2xsZXIucG9sYXJBcmVhLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJDaGFydCIsImhlbHBlcnMiLCJkZWZhdWx0cyIsInBvbGFyQXJlYSIsInNjYWxlIiwidHlwZSIsImxpbmVBcmMiLCJ0aWNrcyIsImJlZ2luQXRaZXJvIiwiYW5pbWF0aW9uIiwiYW5pbWF0ZVJvdGF0ZSIsImFuaW1hdGVTY2FsZSIsInN0YXJ0QW5nbGUiLCJNYXRoIiwiUEkiLCJhc3BlY3RSYXRpbyIsImxlZ2VuZENhbGxiYWNrIiwiY2hhcnQiLCJ0ZXh0IiwicHVzaCIsImlkIiwiZGF0YSIsImRhdGFzZXRzIiwibGFiZWxzIiwibGVuZ3RoIiwiaSIsImJhY2tncm91bmRDb2xvciIsImpvaW4iLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsIm1hcCIsImxhYmVsIiwibWV0YSIsImdldERhdGFzZXRNZXRhIiwiZHMiLCJhcmMiLCJjdXN0b20iLCJnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJhcmNPcHRzIiwib3B0aW9ucyIsImVsZW1lbnRzIiwiZmlsbCIsInN0cm9rZSIsImJvcmRlckNvbG9yIiwiYnciLCJib3JkZXJXaWR0aCIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiaGlkZGVuIiwiaXNOYU4iLCJpbmRleCIsIm9uQ2xpY2siLCJlIiwibGVnZW5kSXRlbSIsImlsZW4iLCJ1cGRhdGUiLCJ0b29sdGlwcyIsImNhbGxiYWNrcyIsInRpdGxlIiwidG9vbHRpcEl0ZW0iLCJ5TGFiZWwiLCJjb250cm9sbGVycyIsIkRhdGFzZXRDb250cm9sbGVyIiwiZXh0ZW5kIiwiZGF0YUVsZW1lbnRUeXBlIiwiQXJjIiwibGlua1NjYWxlcyIsIm5vb3AiLCJyZXNldCIsIm1lIiwiY2hhcnRBcmVhIiwiZ2V0TWV0YSIsIm9wdHMiLCJtaW5TaXplIiwibWluIiwicmlnaHQiLCJsZWZ0IiwiYm90dG9tIiwidG9wIiwib3V0ZXJSYWRpdXMiLCJtYXgiLCJpbm5lclJhZGl1cyIsImN1dG91dFBlcmNlbnRhZ2UiLCJyYWRpdXNMZW5ndGgiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwiY291bnQiLCJjb3VudFZpc2libGVFbGVtZW50cyIsImVhY2giLCJ1cGRhdGVFbGVtZW50IiwiZGF0YXNldCIsImdldERhdGFzZXQiLCJhbmltYXRpb25PcHRzIiwiY2lyY3VtZmVyZW5jZSIsImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCJjZW50ZXJYIiwieENlbnRlciIsImNlbnRlclkiLCJ5Q2VudGVyIiwidmlzaWJsZUNvdW50IiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJkaXN0YW5jZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwiZW5kQW5nbGUiLCJyZXNldFJhZGl1cyIsIl9kYXRhc2V0SW5kZXgiLCJfaW5kZXgiLCJfc2NhbGUiLCJfbW9kZWwiLCJ4IiwieSIsInJlbW92ZUhvdmVyU3R5bGUiLCJwaXZvdCIsInByb3RvdHlwZSIsImNhbGwiLCJlbGVtZW50IiwidmFsdWUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLEtBQVQsRUFBZ0I7O0FBRWhDLEtBQUlDLFVBQVVELE1BQU1DLE9BQXBCOztBQUVBRCxPQUFNRSxRQUFOLENBQWVDLFNBQWYsR0FBMkI7O0FBRTFCQyxTQUFPO0FBQ05DLFNBQU0sY0FEQTtBQUVOQyxZQUFTLElBRkgsRUFFUztBQUNmQyxVQUFPO0FBQ05DLGlCQUFhO0FBRFA7QUFIRCxHQUZtQjs7QUFVMUI7QUFDQUMsYUFBVztBQUNWQyxrQkFBZSxJQURMO0FBRVZDLGlCQUFjO0FBRkosR0FYZTs7QUFnQjFCQyxjQUFZLENBQUMsR0FBRCxHQUFPQyxLQUFLQyxFQWhCRTtBQWlCMUJDLGVBQWEsQ0FqQmE7QUFrQjFCQyxrQkFBZ0Isd0JBQVNDLEtBQVQsRUFBZ0I7QUFDL0IsT0FBSUMsT0FBTyxFQUFYO0FBQ0FBLFFBQUtDLElBQUwsQ0FBVSxnQkFBZ0JGLE1BQU1HLEVBQXRCLEdB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QVFyRSxJQUFSLENBQWE4QixLQUFiLENBQU4sQ0FBRCxJQUErQixDQUFDZ0UsUUFBUWxFLE1BQTVDLEVBQW9EO0FBQ25EcUM7QUFDQTtBQUNELElBSkQ7O0FBTUEsVUFBT0EsS0FBUDtBQUNBLEdBcEcyRDs7QUFzRzVEUSwwQkFBd0IsZ0NBQVNzQixLQUFULEVBQWdCO0FBQ3ZDLE9BQUk5QixRQUFRLEtBQUtkLE9BQUwsR0FBZWMsS0FBM0I7QUFDQSxPQUFJQSxRQUFRLENBQVIsSUFBYSxDQUFDcEMsTUFBTWtFLEtBQU4sQ0FBbEIsRUFBZ0M7QUFDL0IsV0FBUSxJQUFJdkcsS0FBS0MsRUFBVixHQUFnQndFLEtBQXZCO0FBQ0E7QUFDRCxVQUFPLENBQVA7QUFDQTtBQTVHMkQsRUFBL0IsQ0FBOUI7QUE4R0EsQ0FwTkQiLCJmaWxlIjoiY29udHJvbGxlci5wb2xhckFyZWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XHJcblxyXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcclxuXHJcblx0Q2hhcnQuZGVmYXVsdHMucG9sYXJBcmVhID0ge1xyXG5cclxuXHRcdHNjYWxlOiB7XHJcblx0XHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxyXG5cdFx0XHRsaW5lQXJjOiB0cnVlLCAvLyBzbyB0aGF0IGxpbmVzIGFyZSBjaXJjdWxhclxyXG5cdFx0XHR0aWNrczoge1xyXG5cdFx0XHRcdGJlZ2luQXRaZXJvOiB0cnVlXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XHJcblx0XHRhbmltYXRpb246IHtcclxuXHRcdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcclxuXHRcdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXHJcblx0XHR9LFxyXG5cclxuXHRcdHN0YXJ0QW5nbGU6IC0wLjUgKiBNYXRoLlBJLFxyXG5cdFx0YXNwZWN0UmF0aW86IDEsXHJcblx0XHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcclxuXHRcdFx0dmFyIHRleHQgPSBbXTtcclxuXHRcdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cdFx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xyXG5cdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XHJcblxyXG5cdFx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XHJcblx0XHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XHJcblx0XHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xyXG5cdFx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcclxuXHRcdH0sXHJcblx0XHRsZWdlbmQ6IHtcclxuXHRcdFx0bGFiZWxzOiB7XHJcblx0XHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XHJcblx0XHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQ7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcclxuXHRcdFx0XHRcdFx0XHR2YXIgZmlsbCA9IGN1c3RvbS5iYWNrZ3JvdW5kQ29sb3IgPyBjdXN0b20uYmFja2dyb3VuZENvbG9yIDogZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0KGRzLmJhY2tncm91bmRDb2xvciwgaSwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3IpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSBjdXN0b20uYm9yZGVyQ29sb3IgPyBjdXN0b20uYm9yZGVyQ29sb3IgOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQoZHMuYm9yZGVyQ29sb3IsIGksIGFyY09wdHMuYm9yZGVyQ29sb3IpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBidyA9IGN1c3RvbS5ib3JkZXJXaWR0aCA/IGN1c3RvbS5ib3JkZXJXaWR0aCA6IGdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkcy5ib3JkZXJXaWR0aCwgaSwgYXJjT3B0cy5ib3JkZXJXaWR0aCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcclxuXHRcdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcclxuXHRcdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXHJcblx0XHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxyXG5cdFx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XHJcblx0XHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcclxuXHRcdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG5cdFx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG5cdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjaGFydC51cGRhdGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcclxuXHRcdHRvb2x0aXBzOiB7XHJcblx0XHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiAnJztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW3Rvb2x0aXBJdGVtLmluZGV4XSArICc6ICcgKyB0b29sdGlwSXRlbS55TGFiZWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Q2hhcnQuY29udHJvbGxlcnMucG9sYXJBcmVhID0gQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcclxuXHJcblx0XHRkYXRhRWxlbWVudFR5cGU6IENoYXJ0LmVsZW1lbnRzLkFyYyxcclxuXHJcblx0XHRsaW5rU2NhbGVzOiBoZWxwZXJzLm5vb3AsXHJcblxyXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcclxuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdFx0dmFyIGFyY09wdHMgPSBvcHRzLmVsZW1lbnRzLmFyYztcclxuXHRcdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xyXG5cdFx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gYXJjT3B0cy5ib3JkZXJXaWR0aCAvIDIpIC8gMiwgMCk7XHJcblx0XHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XHJcblx0XHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcclxuXHJcblx0XHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xyXG5cdFx0XHRtZS5pbm5lclJhZGl1cyA9IG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoO1xyXG5cclxuXHRcdFx0bWV0YS5jb3VudCA9IG1lLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XHJcblxyXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihhcmMsIGluZGV4KSB7XHJcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmMsIGluZGV4LCByZXNldCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcclxuXHRcdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XHJcblx0XHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuXHRcdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcclxuXHRcdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XHJcblx0XHRcdHZhciBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdDtcclxuXHRcdFx0dmFyIGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzO1xyXG5cclxuXHRcdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xyXG5cdFx0XHR2YXIgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XHJcblx0XHRcdHZhciBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcclxuXHJcblx0XHRcdC8vIElmIHRoZXJlIGlzIE5hTiBkYXRhIGJlZm9yZSB1cywgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIHN0YXJ0aW5nIGFuZ2xlIGNvcnJlY3RseS5cclxuXHRcdFx0Ly8gV2UgY291bGQgYmUgd2F5IG1vcmUgZWZmaWNpZW50IGhlcmUsIGJ1dCBpdHMgdW5saWtlbHkgdGhhdCB0aGUgcG9sYXIgYXJlYSBjaGFydCB3aWxsIGhhdmUgYSBsb3Qgb2YgZGF0YVxyXG5cdFx0XHR2YXIgdmlzaWJsZUNvdW50ID0gMDtcclxuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7ICsraSkge1xyXG5cdFx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2ldKSAmJiAhbWV0YS5kYXRhW2ldLmhpZGRlbikge1xyXG5cdFx0XHRcdFx0Kyt2aXNpYmxlQ291bnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XHJcblx0XHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gYXJjLmhpZGRlbiA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcclxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZSArIChjaXJjdW1mZXJlbmNlICogdmlzaWJsZUNvdW50KTtcclxuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IGNpcmN1bWZlcmVuY2UpO1xyXG5cclxuXHRcdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XHJcblxyXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChhcmMsIHtcclxuXHRcdFx0XHQvLyBVdGlsaXR5XHJcblx0XHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXHJcblx0XHRcdFx0X2luZGV4OiBpbmRleCxcclxuXHRcdFx0XHRfc2NhbGU6IHNjYWxlLFxyXG5cclxuXHRcdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xyXG5cdFx0XHRcdF9tb2RlbDoge1xyXG5cdFx0XHRcdFx0eDogY2VudGVyWCxcclxuXHRcdFx0XHRcdHk6IGNlbnRlclksXHJcblx0XHRcdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0XHRcdG91dGVyUmFkaXVzOiByZXNldCA/IHJlc2V0UmFkaXVzIDogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRzdGFydEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IHN0YXJ0QW5nbGUsXHJcblx0XHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcclxuXHRcdFx0XHRcdGxhYmVsOiBnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gQXBwbHkgYm9yZGVyIGFuZCBmaWxsIHN0eWxlXHJcblx0XHRcdG1lLnJlbW92ZUhvdmVyU3R5bGUoYXJjKTtcclxuXHJcblx0XHRcdGFyYy5waXZvdCgpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcclxuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUhvdmVyU3R5bGUuY2FsbCh0aGlzLCBhcmMsIHRoaXMuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XHJcblx0XHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XHJcblx0XHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0XHRoZWxwZXJzLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xyXG5cdFx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XHJcblx0XHRcdFx0XHRjb3VudCsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY291bnQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xyXG5cdFx0XHRpZiAoY291bnQgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gKDIgKiBNYXRoLlBJKSAvIGNvdW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG4iXX0=