'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (Chart) {

	var helpers = Chart.helpers;

	Chart.defaults.bubble = {
		hover: {
			mode: 'single'
		},

		scales: {
			xAxes: [{
				type: 'linear', // bubble should probably use a linear scale by default
				position: 'bottom',
				id: 'x-axis-0' // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: 'linear',
				position: 'left',
				id: 'y-axis-0'
			}]
		},

		tooltips: {
			callbacks: {
				title: function title() {
					// Title doesn't make sense for scatter since we format the data as a point
					return '';
				},
				label: function label(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';
					var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
					return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';
				}
			}
		}
	};

	Chart.controllers.bubble = Chart.DatasetController.extend({

		dataElementType: Chart.elements.Point,

		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data;

			// Update Points
			helpers.each(points, function (point, index) {
				me.updateElement(point, index, reset);
			});
		},

		updateElement: function updateElement(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);

			var custom = point.custom || {};
			var dataset = me.getDataset();
			var data = dataset.data[index];
			var pointElementOptions = me.chart.options.elements.point;
			var dsIndex = me.index;

			helpers.extend(point, {
				// Utility
				_xScale: xScale,
				_yScale: yScale,
				_datasetIndex: dsIndex,
				_index: index,

				// Desired view properties
				_model: {
					x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),
					y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
					// Appearance
					radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),

					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
				}
			});

			// Trick to reset the styles of the point
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);

			var model = point._model;
			model.skip = custom.skip ? custom.skip : isNaN(model.x) || isNaN(model.y);

			point.pivot();
		},

		getRadius: function getRadius(value) {
			return value.r || this.chart.options.elements.point.radius;
		},

		setHoverStyle: function setHoverStyle(point) {
			var me = this;
			Chart.DatasetController.prototype.setHoverStyle.call(me, point);

			// Radius
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;
			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius) + me.getRadius(dataset.data[index]);
		},

		removeHoverStyle: function removeHoverStyle(point) {
			var me = this;
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);

			var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
			var custom = point.custom || {};
			var model = point._model;

			model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);
		}
	});
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbnRyb2xsZXIuYnViYmxlLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJDaGFydCIsImhlbHBlcnMiLCJkZWZhdWx0cyIsImJ1YmJsZSIsImhvdmVyIiwibW9kZSIsInNjYWxlcyIsInhBeGVzIiwidHlwZSIsInBvc2l0aW9uIiwiaWQiLCJ5QXhlcyIsInRvb2x0aXBzIiwiY2FsbGJhY2tzIiwidGl0bGUiLCJsYWJlbCIsInRvb2x0aXBJdGVtIiwiZGF0YSIsImRhdGFzZXRMYWJlbCIsImRhdGFzZXRzIiwiZGF0YXNldEluZGV4IiwiZGF0YVBvaW50IiwiaW5kZXgiLCJ4TGFiZWwiLCJ5TGFiZWwiLCJyIiwiY29udHJvbGxlcnMiLCJEYXRhc2V0Q29udHJvbGxlciIsImV4dGVuZCIsImRhdGFFbGVtZW50VHlwZSIsImVsZW1lbnRzIiwiUG9pbnQiLCJ1cGRhdGUiLCJyZXNldCIsIm1lIiwibWV0YSIsImdldE1ldGEiLCJwb2ludHMiLCJlYWNoIiwicG9pbnQiLCJ1cGRhdGVFbGVtZW50IiwieFNjYWxlIiwiZ2V0U2NhbGVGb3JJZCIsInhBeGlzSUQiLCJ5U2NhbGUiLCJ5QXhpc0lEIiwiY3VzdG9tIiwiZGF0YXNldCIsImdldERhdGFzZXQiLCJwb2ludEVsZW1lbnRPcHRpb25zIiwiY2hhcnQiLCJvcHRpb25zIiwiZHNJbmRleCIsIl94U2NhbGUiLCJfeVNjYWxlIiwiX2RhdGFzZXRJbmRleCIsIl9pbmRleCIsIl9tb2RlbCIsIngiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJnZXRQaXhlbEZvclZhbHVlIiwiTmFOIiwiaXNDb21ibyIsInkiLCJnZXRCYXNlUGl4ZWwiLCJyYWRpdXMiLCJnZXRSYWRpdXMiLCJoaXRSYWRpdXMiLCJnZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJwcm90b3R5cGUiLCJyZW1vdmVIb3ZlclN0eWxlIiwiY2FsbCIsIm1vZGVsIiwic2tpcCIsImlzTmFOIiwicGl2b3QiLCJ2YWx1ZSIsInNldEhvdmVyU3R5bGUi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QyxJQUE1QyxDQUFpRHNCLE1BQU1pQixNQUF2RCxDQUFkO0FBQ0EsT0FBSVYsU0FBU1AsTUFBTU8sTUFBTixJQUFnQixFQUE3QjtBQUNBLE9BQUkwQixRQUFRakMsTUFBTWtCLE1BQWxCOztBQUVBZSxTQUFNUCxNQUFOLEdBQWVuQixPQUFPbUIsTUFBUCxHQUFnQm5CLE9BQU9tQixNQUF2QixHQUFnQy9CLEdBQUdnQyxTQUFILENBQWFhLE9BQWIsQ0FBL0M7QUFDQTtBQWhGd0QsRUFBL0IsQ0FBM0I7QUFrRkEsQ0F2SEQiLCJmaWxlIjoiY29udHJvbGxlci5idWJibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XHJcblxyXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcclxuXHJcblx0Q2hhcnQuZGVmYXVsdHMuYnViYmxlID0ge1xyXG5cdFx0aG92ZXI6IHtcclxuXHRcdFx0bW9kZTogJ3NpbmdsZSdcclxuXHRcdH0sXHJcblxyXG5cdFx0c2NhbGVzOiB7XHJcblx0XHRcdHhBeGVzOiBbe1xyXG5cdFx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XHJcblx0XHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxyXG5cdFx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcclxuXHRcdFx0fV0sXHJcblx0XHRcdHlBeGVzOiBbe1xyXG5cdFx0XHRcdHR5cGU6ICdsaW5lYXInLFxyXG5cdFx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXHJcblx0XHRcdFx0aWQ6ICd5LWF4aXMtMCdcclxuXHRcdFx0fV1cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9vbHRpcHM6IHtcclxuXHRcdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XHJcblx0XHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcclxuXHRcdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XHJcblx0XHRcdFx0XHR2YXIgZGF0YVBvaW50ID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFzZXRMYWJlbCArICc6ICgnICsgdG9vbHRpcEl0ZW0ueExhYmVsICsgJywgJyArIHRvb2x0aXBJdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDaGFydC5jb250cm9sbGVycy5idWJibGUgPSBDaGFydC5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xyXG5cclxuXHRcdGRhdGFFbGVtZW50VHlwZTogQ2hhcnQuZWxlbWVudHMuUG9pbnQsXHJcblxyXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcclxuXHRcdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBQb2ludHNcclxuXHRcdFx0aGVscGVycy5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XHJcblx0XHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XHJcblx0XHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XHJcblx0XHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XHJcblxyXG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcclxuXHRcdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xyXG5cdFx0XHR2YXIgcG9pbnRFbGVtZW50T3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XHJcblx0XHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XHJcblxyXG5cdFx0XHRoZWxwZXJzLmV4dGVuZChwb2ludCwge1xyXG5cdFx0XHRcdC8vIFV0aWxpdHlcclxuXHRcdFx0XHRfeFNjYWxlOiB4U2NhbGUsXHJcblx0XHRcdFx0X3lTY2FsZTogeVNjYWxlLFxyXG5cdFx0XHRcdF9kYXRhc2V0SW5kZXg6IGRzSW5kZXgsXHJcblx0XHRcdFx0X2luZGV4OiBpbmRleCxcclxuXHJcblx0XHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcclxuXHRcdFx0XHRfbW9kZWw6IHtcclxuXHRcdFx0XHRcdHg6IHJlc2V0ID8geFNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogeFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YSA6IE5hTiwgaW5kZXgsIGRzSW5kZXgsIG1lLmNoYXJ0LmlzQ29tYm8pLFxyXG5cdFx0XHRcdFx0eTogcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCksXHJcblx0XHRcdFx0XHQvLyBBcHBlYXJhbmNlXHJcblx0XHRcdFx0XHRyYWRpdXM6IHJlc2V0ID8gMCA6IGN1c3RvbS5yYWRpdXMgPyBjdXN0b20ucmFkaXVzIDogbWUuZ2V0UmFkaXVzKGRhdGEpLFxyXG5cclxuXHRcdFx0XHRcdC8vIFRvb2x0aXBcclxuXHRcdFx0XHRcdGhpdFJhZGl1czogY3VzdG9tLmhpdFJhZGl1cyA/IGN1c3RvbS5oaXRSYWRpdXMgOiBoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmhpdFJhZGl1cywgaW5kZXgsIHBvaW50RWxlbWVudE9wdGlvbnMuaGl0UmFkaXVzKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBUcmljayB0byByZXNldCB0aGUgc3R5bGVzIG9mIHRoZSBwb2ludFxyXG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKG1lLCBwb2ludCwgcG9pbnRFbGVtZW50T3B0aW9ucyk7XHJcblxyXG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHRcdG1vZGVsLnNraXAgPSBjdXN0b20uc2tpcCA/IGN1c3RvbS5za2lwIDogKGlzTmFOKG1vZGVsLngpIHx8IGlzTmFOKG1vZGVsLnkpKTtcclxuXHJcblx0XHRcdHBvaW50LnBpdm90KCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHZhbHVlLnIgfHwgdGhpcy5jaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50LnJhZGl1cztcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdFx0Q2hhcnQuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLnNldEhvdmVyU3R5bGUuY2FsbChtZSwgcG9pbnQpO1xyXG5cclxuXHRcdFx0Ly8gUmFkaXVzXHJcblx0XHRcdHZhciBkYXRhc2V0ID0gbWUuY2hhcnQuZGF0YS5kYXRhc2V0c1twb2ludC5fZGF0YXNldEluZGV4XTtcclxuXHRcdFx0dmFyIGluZGV4ID0gcG9pbnQuX2luZGV4O1xyXG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblx0XHRcdG1vZGVsLnJhZGl1cyA9IGN1c3RvbS5ob3ZlclJhZGl1cyA/IGN1c3RvbS5ob3ZlclJhZGl1cyA6IChoZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmhvdmVyUmFkaXVzLCBpbmRleCwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludC5ob3ZlclJhZGl1cykpICsgbWUuZ2V0UmFkaXVzKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHRDaGFydC5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSG92ZXJTdHlsZS5jYWxsKG1lLCBwb2ludCwgbWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludCk7XHJcblxyXG5cdFx0XHR2YXIgZGF0YVZhbCA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbcG9pbnQuX2RhdGFzZXRJbmRleF0uZGF0YVtwb2ludC5faW5kZXhdO1xyXG5cdFx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XHJcblxyXG5cdFx0XHRtb2RlbC5yYWRpdXMgPSBjdXN0b20ucmFkaXVzID8gY3VzdG9tLnJhZGl1cyA6IG1lLmdldFJhZGl1cyhkYXRhVmFsKTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuIl19