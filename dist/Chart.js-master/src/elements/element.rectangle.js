'use strict';

module.exports = function (Chart) {

	var globalOpts = Chart.defaults.global;

	globalOpts.elements.rectangle = {
		backgroundColor: globalOpts.defaultColor,
		borderWidth: 0,
		borderColor: globalOpts.defaultColor,
		borderSkipped: 'bottom'
	};

	function isVertical(bar) {
		return bar._view.width !== undefined;
	}

	/**
  * Helper function to get the bounds of the bar regardless of the orientation
  * @private
  * @param bar {Chart.Element.Rectangle} the bar
  * @return {Bounds} bounds of the bar
  */
	function getBarBounds(bar) {
		var vm = bar._view;
		var x1, x2, y1, y2;

		if (isVertical(bar)) {
			// vertical
			var halfWidth = vm.width / 2;
			x1 = vm.x - halfWidth;
			x2 = vm.x + halfWidth;
			y1 = Math.min(vm.y, vm.base);
			y2 = Math.max(vm.y, vm.base);
		} else {
			// horizontal bar
			var halfHeight = vm.height / 2;
			x1 = Math.min(vm.x, vm.base);
			x2 = Math.max(vm.x, vm.base);
			y1 = vm.y - halfHeight;
			y2 = vm.y + halfHeight;
		}

		return {
			left: x1,
			top: y1,
			right: x2,
			bottom: y2
		};
	}

	Chart.elements.Rectangle = Chart.Element.extend({
		draw: function draw() {
			var ctx = this._chart.ctx;
			var vm = this._view;

			var halfWidth = vm.width / 2,
			    leftX = vm.x - halfWidth,
			    rightX = vm.x + halfWidth,
			    top = vm.base - (vm.base - vm.y),
			    halfStroke = vm.borderWidth / 2;

			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (vm.borderWidth) {
				leftX += halfStroke;
				rightX -= halfStroke;
				top += halfStroke;
			}

			ctx.beginPath();
			ctx.setFillStyle(vm.backgroundColor);
			ctx.setStrokeStyle(vm.borderColor);
			ctx.setLineWidth(vm.borderWidth);

			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners = [[leftX, vm.base], [leftX, top], [rightX, top], [rightX, vm.base]];

			// Find first (starting) corner with fallback to 'bottom'
			var borders = ['bottom', 'left', 'top', 'right'];
			var startCorner = borders.indexOf(vm.borderSkipped, 0);
			if (startCorner === -1) {
				startCorner = 0;
			}

			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}

			// Draw rectangle from 'startCorner'
			var corner = cornerAt(0);
			ctx.moveTo(corner[0], corner[1]);

			for (var i = 1; i < 4; i++) {
				corner = cornerAt(i);
				ctx.lineTo(corner[0], corner[1]);
			}

			ctx.fill();
			if (vm.borderWidth) {
				ctx.stroke();
			}
		},
		height: function height() {
			var vm = this._view;
			return vm.base - vm.y;
		},
		inRange: function inRange(mouseX, mouseY) {
			var inRange = false;

			if (this._view) {
				var bounds = getBarBounds(this);
				inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},
		inLabelRange: function inLabelRange(mouseX, mouseY) {
			var me = this;
			if (!me._view) {
				return false;
			}

			var inRange = false;
			var bounds = getBarBounds(me);

			if (isVertical(me)) {
				inRange = mouseX >= bounds.left && mouseX <= bounds.right;
			} else {
				inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},
		inXRange: function inXRange(mouseX) {
			var bounds = getBarBounds(this);
			return mouseX >= bounds.left && mouseX <= bounds.right;
		},
		inYRange: function inYRange(mouseY) {
			var bounds = getBarBounds(this);
			return mouseY >= bounds.top && mouseY <= bounds.bottom;
		},
		getCenterPoint: function getCenterPoint() {
			var vm = this._view;
			var x, y;
			if (isVertical(this)) {
				x = vm.x;
				y = (vm.y + vm.base) / 2;
			} else {
				x = (vm.x + vm.base) / 2;
				y = vm.y;
			}

			return { x: x, y: y };
		},
		getArea: function getArea() {
			var vm = this._view;
			return vm.width * Math.abs(vm.y - vm.base);
		},
		tooltipPosition: function tooltipPosition() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVsZW1lbnQucmVjdGFuZ2xlLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJDaGFydCIsImdsb2JhbE9wdHMiLCJkZWZhdWx0cyIsImdsb2JhbCIsImVsZW1lbnRzIiwicmVjdGFuZ2xlIiwiYmFja2dyb3VuZENvbG9yIiwiZGVmYXVsdENvbG9yIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsImJvcmRlclNraXBwZWQiLCJpc1ZlcnRpY2FsIiwiYmFyIiwiX3ZpZXciLCJ3aWR0aCIsInVuZGVmaW5lZCIsImdldEJhckJvdW5kcyIsInZtIiwieDEiLCJ4MiIsInkxIiwieTIiLCJoYWxmV2lkdGgiLCJ4IiwiTWF0aCIsIm1pbiIsInkiLCJiYXNlIiwibWF4IiwiaGFsZkhlaWdodCIsImhlaWdodCIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsIlJlY3RhbmdsZSIsIkVsZW1lbnQiLCJleHRlbmQiLCJkcmF3IiwiY3R4IiwiX2NoYXJ0IiwibGVmdFgiLCJyaWdodFgiLCJoYWxmU3Ryb2tlIiwiYmVnaW5QYXRoIiwic2V0RmlsbFN0eWxlIiwic2V0U3Ryb2tlU3R5bGUiLCJzZXRMaW5lV2lkdGgiLCJjb3JuZXJzIiwiYm9yZGVycyIsInN0YXJ0Q29ybmVyIiwiaW5kZXhPZiIsImNvcm5lckF0IiwiaW5kZXgiLCJjb3JuZXIiLCJtb3ZlVG8iLCJpIiwibGluZVRvIiwiZmlsbCIsInN0cm9rZSIsImluUmFuZ2UiLCJtb3VzZVgiLCJtb3VzZVkiLCJib3VuZHMiLCJpbkxhYmVsUmFuZ2UiLCJtZSIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJnZXRDZW50ZXJQb2ludCIsImdldEFyZWEiLCJhYnMiLCJ0b29sdGlwUG9zaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNDLEtBQVQsRUFBZ0I7O0FBRWhDLEtBQUlDLGFBQWFELE1BQU1FLFFBQU4sQ0FBZUMsTUFBaEM7O0FBRUFGLFlBQVdHLFFB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QjtBQUNBLElBSEQsTUFHTztBQUNOSixRQUFJLENBQUNOLEdBQUdNLENBQUgsR0FBT04sR0FBR1UsSUFBWCxJQUFtQixDQUF2QjtBQUNBRCxRQUFJVCxHQUFHUyxDQUFQO0FBQ0E7O0FBRUQsVUFBTyxFQUFDSCxHQUFHQSxDQUFKLEVBQU9HLEdBQUdBLENBQVYsRUFBUDtBQUNBLEdBOUc4QztBQStHL0MyQyxXQUFTLG1CQUFXO0FBQ25CLE9BQUlwRCxLQUFLLEtBQUtKLEtBQWQ7QUFDQSxVQUFPSSxHQUFHSCxLQUFILEdBQVdVLEtBQUs4QyxHQUFMLENBQVNyRCxHQUFHUyxDQUFILEdBQU9ULEdBQUdVLElBQW5CLENBQWxCO0FBQ0EsR0FsSDhDO0FBbUgvQzRDLG1CQUFpQiwyQkFBVztBQUMzQixPQUFJdEQsS0FBSyxLQUFLSixLQUFkO0FBQ0EsVUFBTztBQUNOVSxPQUFHTixHQUFHTSxDQURBO0FBRU5HLE9BQUdULEdBQUdTO0FBRkEsSUFBUDtBQUlBO0FBekg4QyxFQUFyQixDQUEzQjtBQTRIQSxDQTdLRCIsImZpbGUiOiJlbGVtZW50LnJlY3RhbmdsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ2hhcnQpIHtcclxuXHJcblx0dmFyIGdsb2JhbE9wdHMgPSBDaGFydC5kZWZhdWx0cy5nbG9iYWw7XHJcblxyXG5cdGdsb2JhbE9wdHMuZWxlbWVudHMucmVjdGFuZ2xlID0ge1xyXG5cdFx0YmFja2dyb3VuZENvbG9yOiBnbG9iYWxPcHRzLmRlZmF1bHRDb2xvcixcclxuXHRcdGJvcmRlcldpZHRoOiAwLFxyXG5cdFx0Ym9yZGVyQ29sb3I6IGdsb2JhbE9wdHMuZGVmYXVsdENvbG9yLFxyXG5cdFx0Ym9yZGVyU2tpcHBlZDogJ2JvdHRvbSdcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBpc1ZlcnRpY2FsKGJhcikge1xyXG5cdFx0cmV0dXJuIGJhci5fdmlldy53aWR0aCAhPT0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSBiYXIge0NoYXJ0LkVsZW1lbnQuUmVjdGFuZ2xlfSB0aGUgYmFyXHJcblx0ICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIpIHtcclxuXHRcdHZhciB2bSA9IGJhci5fdmlldztcclxuXHRcdHZhciB4MSwgeDIsIHkxLCB5MjtcclxuXHJcblx0XHRpZiAoaXNWZXJ0aWNhbChiYXIpKSB7XHJcblx0XHRcdC8vIHZlcnRpY2FsXHJcblx0XHRcdHZhciBoYWxmV2lkdGggPSB2bS53aWR0aCAvIDI7XHJcblx0XHRcdHgxID0gdm0ueCAtIGhhbGZXaWR0aDtcclxuXHRcdFx0eDIgPSB2bS54ICsgaGFsZldpZHRoO1xyXG5cdFx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xyXG5cdFx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaG9yaXpvbnRhbCBiYXJcclxuXHRcdFx0dmFyIGhhbGZIZWlnaHQgPSB2bS5oZWlnaHQgLyAyO1xyXG5cdFx0XHR4MSA9IE1hdGgubWluKHZtLngsIHZtLmJhc2UpO1xyXG5cdFx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xyXG5cdFx0XHR5MSA9IHZtLnkgLSBoYWxmSGVpZ2h0O1xyXG5cdFx0XHR5MiA9IHZtLnkgKyBoYWxmSGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGxlZnQ6IHgxLFxyXG5cdFx0XHR0b3A6IHkxLFxyXG5cdFx0XHRyaWdodDogeDIsXHJcblx0XHRcdGJvdHRvbTogeTJcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRDaGFydC5lbGVtZW50cy5SZWN0YW5nbGUgPSBDaGFydC5FbGVtZW50LmV4dGVuZCh7XHJcblx0XHRkcmF3OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcclxuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHJcblx0XHRcdHZhciBoYWxmV2lkdGggPSB2bS53aWR0aCAvIDIsXHJcblx0XHRcdFx0bGVmdFggPSB2bS54IC0gaGFsZldpZHRoLFxyXG5cdFx0XHRcdHJpZ2h0WCA9IHZtLnggKyBoYWxmV2lkdGgsXHJcblx0XHRcdFx0dG9wID0gdm0uYmFzZSAtICh2bS5iYXNlIC0gdm0ueSksXHJcblx0XHRcdFx0aGFsZlN0cm9rZSA9IHZtLmJvcmRlcldpZHRoIC8gMjtcclxuXHJcblx0XHRcdC8vIENhbnZhcyBkb2Vzbid0IGFsbG93IHVzIHRvIHN0cm9rZSBpbnNpZGUgdGhlIHdpZHRoIHNvIHdlIGNhblxyXG5cdFx0XHQvLyBhZGp1c3QgdGhlIHNpemVzIHRvIGZpdCBpZiB3ZSdyZSBzZXR0aW5nIGEgc3Ryb2tlIG9uIHRoZSBsaW5lXHJcblx0XHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xyXG5cdFx0XHRcdGxlZnRYICs9IGhhbGZTdHJva2U7XHJcblx0XHRcdFx0cmlnaHRYIC09IGhhbGZTdHJva2U7XHJcblx0XHRcdFx0dG9wICs9IGhhbGZTdHJva2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0Y3R4LnNldEZpbGxTdHlsZSh2bS5iYWNrZ3JvdW5kQ29sb3IpO1xyXG5cdFx0XHRjdHguc2V0U3Ryb2tlU3R5bGUodm0uYm9yZGVyQ29sb3IpO1xyXG5cdFx0XHRjdHguc2V0TGluZVdpZHRoKHZtLmJvcmRlcldpZHRoKTtcclxuXHJcblx0XHRcdC8vIENvcm5lciBwb2ludHMsIGZyb20gYm90dG9tLWxlZnQgdG8gYm90dG9tLXJpZ2h0IGNsb2Nrd2lzZVxyXG5cdFx0XHQvLyB8IDEgMiB8XHJcblx0XHRcdC8vIHwgMCAzIHxcclxuXHRcdFx0dmFyIGNvcm5lcnMgPSBbXHJcblx0XHRcdFx0W2xlZnRYLCB2bS5iYXNlXSxcclxuXHRcdFx0XHRbbGVmdFgsIHRvcF0sXHJcblx0XHRcdFx0W3JpZ2h0WCwgdG9wXSxcclxuXHRcdFx0XHRbcmlnaHRYLCB2bS5iYXNlXVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0Ly8gRmluZCBmaXJzdCAoc3RhcnRpbmcpIGNvcm5lciB3aXRoIGZhbGxiYWNrIHRvICdib3R0b20nXHJcblx0XHRcdHZhciBib3JkZXJzID0gWydib3R0b20nLCAnbGVmdCcsICd0b3AnLCAncmlnaHQnXTtcclxuXHRcdFx0dmFyIHN0YXJ0Q29ybmVyID0gYm9yZGVycy5pbmRleE9mKHZtLmJvcmRlclNraXBwZWQsIDApO1xyXG5cdFx0XHRpZiAoc3RhcnRDb3JuZXIgPT09IC0xKSB7XHJcblx0XHRcdFx0c3RhcnRDb3JuZXIgPSAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBjb3JuZXJBdChpbmRleCkge1xyXG5cdFx0XHRcdHJldHVybiBjb3JuZXJzWyhzdGFydENvcm5lciArIGluZGV4KSAlIDRdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBEcmF3IHJlY3RhbmdsZSBmcm9tICdzdGFydENvcm5lcidcclxuXHRcdFx0dmFyIGNvcm5lciA9IGNvcm5lckF0KDApO1xyXG5cdFx0XHRjdHgubW92ZVRvKGNvcm5lclswXSwgY29ybmVyWzFdKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgNDsgaSsrKSB7XHJcblx0XHRcdFx0Y29ybmVyID0gY29ybmVyQXQoaSk7XHJcblx0XHRcdFx0Y3R4LmxpbmVUbyhjb3JuZXJbMF0sIGNvcm5lclsxXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN0eC5maWxsKCk7XHJcblx0XHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGhlaWdodDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRcdHJldHVybiB2bS5iYXNlIC0gdm0ueTtcclxuXHRcdH0sXHJcblx0XHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0XHR2YXIgaW5SYW5nZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuX3ZpZXcpIHtcclxuXHRcdFx0XHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHRoaXMpO1xyXG5cdFx0XHRcdGluUmFuZ2UgPSBtb3VzZVggPj0gYm91bmRzLmxlZnQgJiYgbW91c2VYIDw9IGJvdW5kcy5yaWdodCAmJiBtb3VzZVkgPj0gYm91bmRzLnRvcCAmJiBtb3VzZVkgPD0gYm91bmRzLmJvdHRvbTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGluUmFuZ2U7XHJcblx0XHR9LFxyXG5cdFx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHRpZiAoIW1lLl92aWV3KSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaW5SYW5nZSA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKG1lKTtcclxuXHJcblx0XHRcdGlmIChpc1ZlcnRpY2FsKG1lKSkge1xyXG5cdFx0XHRcdGluUmFuZ2UgPSBtb3VzZVggPj0gYm91bmRzLmxlZnQgJiYgbW91c2VYIDw9IGJvdW5kcy5yaWdodDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpblJhbmdlID0gbW91c2VZID49IGJvdW5kcy50b3AgJiYgbW91c2VZIDw9IGJvdW5kcy5ib3R0b207XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpblJhbmdlO1xyXG5cdFx0fSxcclxuXHRcdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcclxuXHRcdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh0aGlzKTtcclxuXHRcdFx0cmV0dXJuIG1vdXNlWCA+PSBib3VuZHMubGVmdCAmJiBtb3VzZVggPD0gYm91bmRzLnJpZ2h0O1xyXG5cdFx0fSxcclxuXHRcdGluWVJhbmdlOiBmdW5jdGlvbihtb3VzZVkpIHtcclxuXHRcdFx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh0aGlzKTtcclxuXHRcdFx0cmV0dXJuIG1vdXNlWSA+PSBib3VuZHMudG9wICYmIG1vdXNlWSA8PSBib3VuZHMuYm90dG9tO1xyXG5cdFx0fSxcclxuXHRcdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdFx0dmFyIHgsIHk7XHJcblx0XHRcdGlmIChpc1ZlcnRpY2FsKHRoaXMpKSB7XHJcblx0XHRcdFx0eCA9IHZtLng7XHJcblx0XHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcclxuXHRcdFx0XHR5ID0gdm0ueTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcclxuXHRcdH0sXHJcblx0XHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHZtID0gdGhpcy5fdmlldztcclxuXHRcdFx0cmV0dXJuIHZtLndpZHRoICogTWF0aC5hYnModm0ueSAtIHZtLmJhc2UpO1xyXG5cdFx0fSxcclxuXHRcdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0eDogdm0ueCxcclxuXHRcdFx0XHR5OiB2bS55XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG59O1xyXG4iXX0=