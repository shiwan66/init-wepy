'use strict';

module.exports = function (Chart) {

	var helpers = Chart.helpers;
	// Default config for a category scale
	var defaultConfig = {
		position: 'bottom'
	};

	var DatasetScale = Chart.Scale.extend({
		/**
  * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
  * else fall back to data.labels
  * @private
  */
		getLabels: function getLabels() {
			var data = this.chart.data;
			return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
		},
		// Implement this so that
		determineDataLimits: function determineDataLimits() {
			var me = this;
			var labels = me.getLabels();
			me.minIndex = 0;
			me.maxIndex = labels.length - 1;
			var findIndex;

			if (me.options.ticks.min !== undefined) {
				// user specified min value
				findIndex = helpers.indexOf(labels, me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}

			if (me.options.ticks.max !== undefined) {
				// user specified max value
				findIndex = helpers.indexOf(labels, me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}

			me.min = labels[me.minIndex];
			me.max = labels[me.maxIndex];
		},

		buildTicks: function buildTicks() {
			var me = this;
			var labels = me.getLabels();
			// If we are viewing some subset of labels, slice the original array
			me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
		},

		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var isHorizontal = me.isHorizontal();

			if (data.xLabels && isHorizontal || data.yLabels && !isHorizontal) {
				return me.getRightValue(data.datasets[datasetIndex].data[index]);
			}
			return me.ticks[index];
		},

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: function getPixelForValue(value, index, datasetIndex, includeOffset) {
			var me = this;
			// 1 is added because we need the length but we have the indexes
			var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);

			if (value !== undefined && isNaN(index)) {
				var labels = me.getLabels();
				var idx = labels.indexOf(value);
				index = idx !== -1 ? idx : index;
			}

			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueWidth = innerWidth / offsetAmt;
				var widthOffset = valueWidth * (index - me.minIndex) + me.paddingLeft;

				if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {
					widthOffset += valueWidth / 2;
				}

				return me.left + Math.round(widthOffset);
			}
			var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
			var valueHeight = innerHeight / offsetAmt;
			var heightOffset = valueHeight * (index - me.minIndex) + me.paddingTop;

			if (me.options.gridLines.offsetGridLines && includeOffset) {
				heightOffset += valueHeight / 2;
			}

			return me.top + Math.round(heightOffset);
		},
		getPixelForTick: function getPixelForTick(index, includeOffset) {
			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
		},
		getValueForPixel: function getValueForPixel(pixel) {
			var me = this;
			var value;
			var offsetAmt = Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);
			var horz = me.isHorizontal();
			var innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
			var valueDimension = innerDimension / offsetAmt;

			pixel -= horz ? me.left : me.top;

			if (me.options.gridLines.offsetGridLines) {
				pixel -= valueDimension / 2;
			}
			pixel -= horz ? me.paddingLeft : me.paddingTop;

			if (pixel <= 0) {
				value = 0;
			} else {
				value = Math.round(pixel / valueDimension);
			}

			return value;
		},
		getBasePixel: function getBasePixel() {
			return this.bottom;
		}
	});

	Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjYWxlLmNhdGVnb3J5LmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJDaGFydCIsImhlbHBlcnMiLCJkZWZhdWx0Q29uZmlnIiwicG9zaXRpb24iLCJEYXRhc2V0U2NhbGUiLCJTY2FsZSIsImV4dGVuZCIsImdldExhYmVscyIsImRhdGEiLCJjaGFydCIsImlzSG9yaXpvbnRhbCIsInhMYWJlbHMiLCJ5TGFiZWxzIiwibGFiZWxzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsIm1lIiwibWluSW5kZXgiLCJtYXhJbmRleCIsImxlbmd0aCIsImZpbmRJbmRleCIsIm9wdGlvbnMiLCJ0aWNrcyIsIm1pbiIsInVuZGVmaW5lZCIsImluZGV4T2YiLCJtYXgiLCJidWlsZFRpY2tzIiwic2xpY2UiLCJnZXRMYWJlbEZvckluZGV4IiwiaW5kZXgiLCJkYXRhc2V0SW5kZXgiLCJnZXRSaWdodFZhbHVlIiwiZGF0YXNldHMiLCJnZXRQaXhlbEZvclZhbHVlIiwidmFsdWUiLCJpbmNsdWRlT2Zmc2V0Iiwib2Zmc2V0QW10IiwiTWF0aCIsImdyaWRMaW5lcyIsIm9mZnNldEdyaWRMaW5lcyIsImlzTmFOIiwiaWR4IiwiaW5uZXJXaWR0aCIsIndpZHRoIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJ2YWx1ZVdpZHRoIiwid2lkdGhPZmZzZXQiLCJsZWZ0Iiwicm91bmQiLCJpbm5lckhlaWdodCIsImhlaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwidmFsdWVIZWlnaHQiLCJoZWlnaHRPZmZzZXQiLCJ0b3AiLCJnZXRQaXhlbEZvclRpY2siLCJnZXRWYWx1ZUZvclBpeGVsIiwicGl4ZWwiLCJob3J6IiwiaW5uZXJEaW1lbnNpb24iLCJ2YWx1ZURpbWVuc2lvbiIsImdldEJhc2VQaXhlbCIsImJvdHRvbSIsInNjYWxlU2VydmljZSIsInJlZ2lzdGVyU2NhbGVUeXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQUEsT0FBT0MsT0FBUCxH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QUgsQ0FBV2tCLFNBQVgsQ0FBcUJDLGVBQXpCLEVBQTBDO0FBQ3pDb0IsYUFBVUcsaUJBQWlCLENBQTNCO0FBQ0E7QUFDREgsWUFBU0MsT0FBTzdDLEdBQUc2QixXQUFWLEdBQXdCN0IsR0FBR3FDLFVBQXBDOztBQUVBLE9BQUlPLFNBQVMsQ0FBYixFQUFnQjtBQUNmekIsWUFBUSxDQUFSO0FBQ0EsSUFGRCxNQUVPO0FBQ05BLFlBQVFHLEtBQUtZLEtBQUwsQ0FBV1UsUUFBUUcsY0FBbkIsQ0FBUjtBQUNBOztBQUVELFVBQU81QixLQUFQO0FBQ0EsR0E5R29DO0FBK0dyQzZCLGdCQUFjLHdCQUFXO0FBQ3hCLFVBQU8sS0FBS0MsTUFBWjtBQUNBO0FBakhvQyxFQUFuQixDQUFuQjs7QUFvSEFoRSxPQUFNaUUsWUFBTixDQUFtQkMsaUJBQW5CLENBQXFDLFVBQXJDLEVBQWlEOUQsWUFBakQsRUFBK0RGLGFBQS9EO0FBRUEsQ0E5SEQiLCJmaWxlIjoic2NhbGUuY2F0ZWdvcnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENoYXJ0KSB7XHJcblxyXG5cdHZhciBoZWxwZXJzID0gQ2hhcnQuaGVscGVycztcclxuXHQvLyBEZWZhdWx0IGNvbmZpZyBmb3IgYSBjYXRlZ29yeSBzY2FsZVxyXG5cdHZhciBkZWZhdWx0Q29uZmlnID0ge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b20nXHJcblx0fTtcclxuXHJcblx0dmFyIERhdGFzZXRTY2FsZSA9IENoYXJ0LlNjYWxlLmV4dGVuZCh7XHJcblx0XHQvKipcclxuXHRcdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGxhYmVscy4gSWYgZGF0YS54TGFiZWxzIG9yIGRhdGEueUxhYmVscyBhcmUgZGVmaW5lZCwgdXNlIHRob3NlXHJcblx0XHQqIGVsc2UgZmFsbCBiYWNrIHRvIGRhdGEubGFiZWxzXHJcblx0XHQqIEBwcml2YXRlXHJcblx0XHQqL1xyXG5cdFx0Z2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XHJcblx0XHRcdHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XHJcblx0XHR9LFxyXG5cdFx0Ly8gSW1wbGVtZW50IHRoaXMgc28gdGhhdFxyXG5cdFx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcclxuXHRcdFx0bWUubWluSW5kZXggPSAwO1xyXG5cdFx0XHRtZS5tYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xyXG5cdFx0XHR2YXIgZmluZEluZGV4O1xyXG5cclxuXHRcdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWluICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcclxuXHRcdFx0XHRmaW5kSW5kZXggPSBoZWxwZXJzLmluZGV4T2YobGFiZWxzLCBtZS5vcHRpb25zLnRpY2tzLm1pbik7XHJcblx0XHRcdFx0bWUubWluSW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWluSW5kZXg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWF4IHZhbHVlXHJcblx0XHRcdFx0ZmluZEluZGV4ID0gaGVscGVycy5pbmRleE9mKGxhYmVscywgbWUub3B0aW9ucy50aWNrcy5tYXgpO1xyXG5cdFx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZS5taW4gPSBsYWJlbHNbbWUubWluSW5kZXhdO1xyXG5cdFx0XHRtZS5tYXggPSBsYWJlbHNbbWUubWF4SW5kZXhdO1xyXG5cdFx0fSxcclxuXHJcblx0XHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcztcclxuXHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xyXG5cdFx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxyXG5cdFx0XHRtZS50aWNrcyA9IChtZS5taW5JbmRleCA9PT0gMCAmJiBtZS5tYXhJbmRleCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1lLm1pbkluZGV4LCBtZS5tYXhJbmRleCArIDEpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XHJcblx0XHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcclxuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xyXG5cclxuXHRcdFx0aWYgKChkYXRhLnhMYWJlbHMgJiYgaXNIb3Jpem9udGFsKSB8fCAoZGF0YS55TGFiZWxzICYmICFpc0hvcml6b250YWwpKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1lLmdldFJpZ2h0VmFsdWUoZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbWUudGlja3NbaW5kZXhdO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcclxuXHRcdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4LCBpbmNsdWRlT2Zmc2V0KSB7XHJcblx0XHRcdHZhciBtZSA9IHRoaXM7XHJcblx0XHRcdC8vIDEgaXMgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBsZW5ndGggYnV0IHdlIGhhdmUgdGhlIGluZGV4ZXNcclxuXHRcdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtICgobWUub3B0aW9ucy5ncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzKSA/IDAgOiAxKSksIDEpO1xyXG5cclxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgaXNOYU4oaW5kZXgpKSB7XHJcblx0XHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xyXG5cdFx0XHRcdHZhciBpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XHJcblx0XHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xyXG5cdFx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xyXG5cdFx0XHRcdHZhciB2YWx1ZVdpZHRoID0gaW5uZXJXaWR0aCAvIG9mZnNldEFtdDtcclxuXHRcdFx0XHR2YXIgd2lkdGhPZmZzZXQgPSAodmFsdWVXaWR0aCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSkgKyBtZS5wYWRkaW5nTGVmdDtcclxuXHJcblx0XHRcdFx0aWYgKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcyAmJiBpbmNsdWRlT2Zmc2V0IHx8IG1lLm1heEluZGV4ID09PSBtZS5taW5JbmRleCAmJiBpbmNsdWRlT2Zmc2V0KSB7XHJcblx0XHRcdFx0XHR3aWR0aE9mZnNldCArPSAodmFsdWVXaWR0aCAvIDIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG1lLmxlZnQgKyBNYXRoLnJvdW5kKHdpZHRoT2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xyXG5cdFx0XHR2YXIgdmFsdWVIZWlnaHQgPSBpbm5lckhlaWdodCAvIG9mZnNldEFtdDtcclxuXHRcdFx0dmFyIGhlaWdodE9mZnNldCA9ICh2YWx1ZUhlaWdodCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSkgKyBtZS5wYWRkaW5nVG9wO1xyXG5cclxuXHRcdFx0aWYgKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcyAmJiBpbmNsdWRlT2Zmc2V0KSB7XHJcblx0XHRcdFx0aGVpZ2h0T2Zmc2V0ICs9ICh2YWx1ZUhlaWdodCAvIDIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWUudG9wICsgTWF0aC5yb3VuZChoZWlnaHRPZmZzZXQpO1xyXG5cdFx0fSxcclxuXHRcdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgsIGluY2x1ZGVPZmZzZXQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XSwgaW5kZXggKyB0aGlzLm1pbkluZGV4LCBudWxsLCBpbmNsdWRlT2Zmc2V0KTtcclxuXHRcdH0sXHJcblx0XHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xyXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cdFx0XHR2YXIgdmFsdWU7XHJcblx0XHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUudGlja3MubGVuZ3RoIC0gKChtZS5vcHRpb25zLmdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpID8gMCA6IDEpKSwgMSk7XHJcblx0XHRcdHZhciBob3J6ID0gbWUuaXNIb3Jpem9udGFsKCk7XHJcblx0XHRcdHZhciBpbm5lckRpbWVuc2lvbiA9IGhvcnogPyBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCkgOiBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xyXG5cdFx0XHR2YXIgdmFsdWVEaW1lbnNpb24gPSBpbm5lckRpbWVuc2lvbiAvIG9mZnNldEFtdDtcclxuXHJcblx0XHRcdHBpeGVsIC09IGhvcnogPyBtZS5sZWZ0IDogbWUudG9wO1xyXG5cclxuXHRcdFx0aWYgKG1lLm9wdGlvbnMuZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykge1xyXG5cdFx0XHRcdHBpeGVsIC09ICh2YWx1ZURpbWVuc2lvbiAvIDIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBpeGVsIC09IGhvcnogPyBtZS5wYWRkaW5nTGVmdCA6IG1lLnBhZGRpbmdUb3A7XHJcblxyXG5cdFx0XHRpZiAocGl4ZWwgPD0gMCkge1xyXG5cdFx0XHRcdHZhbHVlID0gMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0sXHJcblx0XHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdENoYXJ0LnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSgnY2F0ZWdvcnknLCBEYXRhc2V0U2NhbGUsIGRlZmF1bHRDb25maWcpO1xyXG5cclxufTtcclxuIl19